<html><body style="font-size:150%">
Welcome to the wonderful world of Phaser. I will show how to create a small game involving a player running and jumping around platforms collecting stars. The images are provided free from Phaser. While going through this process I'll explain some of the core features and how to use them.

<h3>What is Phaser?</h3>

<strong>Phaser</strong> is an HTML5 gamimg engine which helps developers make powerful, HTML5 games quickly and has decent mobile support. The only real browser requirement is the canvas tag.
<h2>NEXT</h2>
<h3>Requirements</h3>

<ul>
    <li><strong>Phaser</strong> script itself</li>
	<li>Comfortable with JavaScript</li>
	<li>Hosting environment -- my examples will be on my own website, moviemink.com/phaser</li>
</ul>

Let's have a closer look at the code. It includes Phaser and the code structure looks like this:
 
<pre class="lang:js decode:true " >
var game = new Phaser.Game(800, 600, Phaser.AUTO, '', { preload: preload, create: create, update: update });

function preload() {
}

function create() {
}

function update() {
}
</pre> 

This first line is where you bring Phaser to life by creating an instance of a "Phaser.Game" object and assigning it to a variable I've called 'game'.<br>
<br>
The first two parameters are the width and the height of the canvas element that Phaser will create. In this case 800 x 600 pixels. The game world may be much larger than this, but this is the resolution the game will display in. The third parameter sets the render context. This can be explicitly set to something like "Phaser.CANVAS", but "AUTO" is good practice.<br>
<br>
The fourth parameter can be an empty string or the id of the DOM element in which you would like to insert the canvas element that Phaser creates. <br>
<br>The last parameter is an object containing game-specific preferences. You can learn more about these from the website.<br>
<br>I've also added a few functions Phaser always expects to see.
<h2>NEXT</h2>
<h3>Load Assets</h3>

Let's load the assets we need for our game. You do this by putting calls to game.load inside of our "preload" function. Phaser will automatically look for this function when it starts and load anything defined in it.
<br>
<br>
Let's load 4 assets we'll need for our game 
<pre class="lang:js decode:true " >function preload() {

    game.load.image('sky', 'assets/sky.png');
    game.load.image('ground', 'assets/platform.png');
    game.load.image('star', 'assets/star.png');
    game.load.spritesheet('dude', 'assets/dude.png', 32, 48);

}
</pre> 

I would like to point out the first parameter, also known as the asset key. This is our link to the loaded asset and you'll need it in your code when creating sprites. The last asset is identified as a spritesheet. 

<h3>Let's Create a Sprite</h3>
<h2>NEXT</h2>
In order to add a sprite to our game we only need a simple line of code:

<pre class="lang:js decode:true ">game.add.sprite(0, 0, 'star');</pre>

<img src="http://www.photonstorm.com/wp-content/uploads/2013/12/part3.png" alt="part3" width="800" height="600" class="alignnone size-full wp-image-13605" />

<br>The order in which items are rendered in the display matches the order in which you create them. So the background needs to be before the star sprites or they wouldn't be seen.

<h3>The World</h3> 
<h2>NEXT</h2>
A Phaser game world has no fixed size and extends infinitely in all directions, with 0,0 being the center of it. For convenience Phaser places 0,0 at the top left of your game for you, but by using Phaser's built-in Camera, you can move around as needed.<br>
<br>
The world class can be accessed via game.world and comes with a lot of methods and properties to help you distribute your objects inside the world. It includes some simple properties like game.world.height, but also tons of others to fit different styles of games.<br>
<br>
Our game is starting to feel a little more domestic: Take a look at our create function:<br>
 (SKIP PAST CODE)
<pre class="lang:js decode:true " >var platforms;

function create() {

    //  We're going to be using physics, so enable the Arcade Physics system
    game.physics.startSystem(Phaser.Physics.ARCADE);

    //  The platforms group contains the ground and the 2 ledges we can jump on
    platforms = game.add.group();

    //  We will enable physics for any object that is created in this group
    platforms.enableBody = true;

    // Here we create the ground.
    var floor = platforms.create(0, game.world.height - 64, 'ground');

    //  Scale it to fit the width of the game (the original sprite is 400x32 in size)
    floor.scale.setTo(2, 2);

    //  This stops it from falling away when you jump on it
    floor.body.immovable = true;

    //  Now let's create two ledges
    var ledge1 = platforms.create(400, 400, 'ground');
    var ledge2 = platforms.create(-150, 250, 'ground');

    // Make them immovable as well
    ledge1.body.immovable = true;
    ledge2.body.immovable = true;
    
}
</pre> 

Phaser has support for a variety of different physics systems. For the sake of time we will only be covering the Arcade Physics system, which is simple and light-weight, good for mobile browsers. You'll notice in the code that we have to start the physics system running, and then for every sprite or Group that we wish to use physics on we enable them.<br>

<img src="http://www.photonstorm.com/wp-content/uploads/2013/12/part4.png" alt="part4" width="800" height="600" class="alignnone size-full wp-image-13606" />
<h1>ONE THIRD!</h1>
<h3>Groups</h3> 

Groups are really powerful. As their name implies they allow you to group together similar objects and control them all as one single unit. You can also check for collision between Groups.

<pre class="lang:js decode:true">platforms = game.add.group();</pre>

Similar to sprites, game.add creates our Group object. We assign it to a new variable called platforms. Once created we can add objects to it. First up is the ground. This is positioned at the bottom of the game and uses the 'ground' image loaded earlier. The ground is scaled to fill the width of the game. Finally we set its 'immovable' property to true. Had we not done this the ground would move when the player hits it.

With the ground in place we create two smaller ledges to jump on to using the exact same technique as for the ground.

<h3>Ready Player One with Gravity</h3>
<h2>NEXT</h2>
Create a new variable called 'player' and add the following code to the create function.
 
<pre class="lang:js decode:true " >    // The player and its settings
    player = game.add.sprite(32, game.world.height - 450, 'dude');

    //  We need to enable physics on the player
    game.physics.arcade.enable(player);

    //  Player physics properties. Give the little guy a slight bounce.
    player.body.bounce.y = 0.2;
    player.body.gravity.y = 300;
    player.body.collideWorldBounds = true;

    //  Our two animations, walking left and right.
    player.animations.add('left', [0, 1, 2, 3], 10, true);
    player.animations.add('right', [5, 6, 7, 8], 10, true);
</pre> 

This creates a new sprite called 'player', positioned at 32 pixels by 450 pixels from the bottom of the game. We're telling it to use the 'dude' asset previously loaded.<br>
<br>

Now the sprites gain a new body property, which is an instance of ArcadePhysics.Body. This represents the sprite as a physical body in Phaser's Arcade Physics engine. The body object has itself a lot of properties that we can play with. To simulate the effects of gravity on a sprite, it's as simple as writing this:
    
<pre class="lang:js decode:true">player.body.gravity.y = 300;</pre>

This is an arbitrary value, but logically, the higher the value, the heavier your object feels and the quicker it falls. Adding this to our code, you see that the player falls down without stopping, completely ignoring the ground we created earlier:<br>
<br>
Gravity seems to be working, but we have a serious problem here. Do you know what we are missing? -- Collision.<br>
<br>
So to allow the player to collide and take advantage of the physics properties we need to introduce a collision check in the update function:
 
<pre class="lang:js decode:true " >function update() {

    //  Collide the player and the stars with the platforms
    game.physics.arcade.collide(player, platforms);

}
</pre> 
<h3>Collision</h3>
<h2>NEXT</h2>
Much better. This is our first change to the update function. It basically tells the player to "collide" with the platforms group. Collision is one of the primary mechanics in any platformer.
<img src="http://www.photonstorm.com/wp-content/uploads/2013/12/part5.png" alt="part5" width="800" height="600" class="alignnone size-full wp-image-13608" />

<br>The update function is called by the core game loop every frame. The Physics.collide function is the one that performs the magic. It takes two objects and tests for collision and performs separation against them. In this case we're giving it the player sprite and the platforms Group. It's clever enough to run collision against all Group members, so this one call will collide against the ground and both ledges. The result is a firm platform:
<h2>NEXT</h2>
Now we add controls to move around our world<br>
<br>
 If you glance back to the preload function you'll see that 'dude' was loaded as a sprite sheet, not an image. That is because it contains animation frames. I've shown what the full sprite sheet looks like:

<img src="http://www.photonstorm.com/wp-content/uploads/2013/12/dude.png" alt="dude" width="288" height="48" class="alignnone size-full wp-image-13607" />

You can see 9 frames in total, 4 for running left, 1 for facing the camera and 4 for running right. Note: Phaser supports flipping sprites to save on animation frames, but for the sake of time we'll keep it old school. We define two animations called 'left' and 'right'. The 'left' animation uses frames 0, 1, 2 and 3 and runs at 10 frames per second. The 'true' parameter tells the animation to loop. This is our standard run-cycle and we repeat it for running in the opposite direction.<br>
<br>


<img src="http://www.photonstorm.com/wp-content/uploads/2013/12/part6.png" alt="part6" width="800" height="600" class="alignnone size-full wp-image-13609" />

<h3>Controlling the player with the keyboard</h3>

Phaser has a built-in Keyboard manager so you don't need to create event handlers. One of the benefits of using that is this handy little function:
    
<pre class="lang:js decode:true " >cursors = game.input.keyboard.createCursorKeys();</pre>

This populates the cursors object with four properties: up, down, left, right, that are all instances of Phaser.Key objects. Then all we need to do is use these in our update loop:
 
<pre class="lang:js decode:true " >    //  Reset the players velocity (movement)
    player.body.velocity.x = 0;

    if (cursors.left.isDown)
    {
        //  Move to the left
        player.body.velocity.x = -150;

        player.animations.play('left');
    }
    else if (cursors.right.isDown)
    {
        //  Move to the right
        player.body.velocity.x = 150;

        player.animations.play('right');
    }
    else
    {
        //  Stand still
        player.animations.stop();

        player.frame = 4;
    }
    
    //  Allow the player to jump if they are touching the ground.
    if (cursors.up.isDown &amp;&amp; player.body.touching.down)
    {
        player.body.velocity.y = -350;
    }
</pre>
<h1>TWO THIRDS!</h1>
Now, let's talk gaming physics:<br>
<br>
The first thing we do is reset the horizontal velocity on the sprite. Then we check to see if the left cursor key is held down. If it is, we apply a negative horizontal velocity and start the 'left' running animation. If they are holding down 'right' instead we literally do the opposite. By clearing the velocity and setting it in this manner, every frame, it creates a 'stop-start' style of movement.<br>
<br>
The player sprite will move only when a key is held down and stop immediately they are not. Phaser also allows you to create more complex motions, with momentum and acceleration, but this gives us the effect we need for this game. The final part of the key check sets the frame to 4 if no keyis held down. Frame 4 in the sprite sheet is the one of the player looking at the camera.

<h3>Jump to it</h3>

The final part of the code adds the ability to jump. The up cursor is our jump key and we test if that is down. However we also test if the player is touching the floor, otherwise they could jump while in mid-air. If both of these conditions are met we apply a vertical velocity of 350 px/sec sq. The player will fall to the ground automatically because of the gravity value we applied to it earlier. With the controls in place we now have a game world we can explore.

<img src="http://www.photonstorm.com/wp-content/uploads/2013/12/part7.png" alt="part7" width="800" height="600" class="alignnone size-full wp-image-13611" />
<h2>NEXT</h2>
<h3>Interaction</h3>

It's time to give our little game a purpose. Let's drop a sprinkling of stars into the scene and allow the player to collect them. To achieve this we'll create a new Group called 'stars' and populate it. Our create function now has the following code:
 
<pre class="lang:js decode:true">    stars = game.add.group();

    //  Here we'll create 12 of them evenly spaced apart
    for (var i = 0; i &lt; 12; i++)
    {
        //  Create a star inside of the 'stars' group
        var star = stars.create(i * 70, 0, 'star');

        //  Let gravity do its thing
        star.body.gravity.y = 6;

        //  This just gives each star a slightly random bounce value
        star.body.bounce.y = 0.7 + Math.random() * 0.2;
    }
</pre> 

The process is similar to when we created the platforms Group. We tell it to create 12 stars in our game. They have our x coordinate incrementing by 70, which means they will be evenly spaced out in the scene. We give them a gravity value so they'll fall down, and a bounce value so they'll bounce a little when they hit the platforms. Bounce is a percentage value. Ours will bounce somewhere between 0.7 and 0.9. We also need to remember to apply collision to your stars group:

<pre class="lang:js decode:true ">game.physics.arcade.collide(stars, platforms);</pre>

Next we will check to see if the player overlaps with a star or not:

<pre class="lang:js decode:true ">game.physics.arcade.overlap(player, stars, collectStar, null, this);</pre>

This tells Phaser to check for an overlap between the player and any member of the stars Group. If found then pass them to the 'collectStar' function:

<pre class="lang:js decode:true">function collectStar (player, star) {
    
    // Removes the star from the screen
    star.kill();

}
</pre>

Quite simply the star is killed, which removes it from display. Running the game now gives us a player that can dash about, jumping, bouncing off the platforms and collecting the stars that fall from above. Not bad for a few lines of simple code :)

<img src="http://www.photonstorm.com/wp-content/uploads/2013/12/part8.png" alt="part8" width="800" height="600" class="alignnone size-full wp-image-13615" />

<h3>Finishing touches</h3>
<h2>NEXT</h2>
The final tweak we'll make is to add a score. To do this we'll make use of a Phaser.Text object. Here we create two new variables, one to hold the actual score and the text object itself:

<pre class="lang:js decode:true">var score = 0;
var scoreText;</pre>

The scoreText is set-up in the create function:

<pre class="lang:js decode:true">scoreText = game.add.text(16, 16, 'score: 0', { fontSize: '32px', fill: '#000' });</pre>

16 and 16 are the world coordinates for the text. 'score: 0' is the default content to display and the object that follows contains properties, similar to css. Next we need to modify the collectStar function so that when the player picks-up a star their score increases and the text is updated to reflect this:

<pre class="lang:js decode:true">function collectStar (player, star) {
    
    // Removes the star from the screen
    star.kill();

    //  Add and update the score
    score += 10;
    scoreText.content = 'Score: ' + score;

}
</pre>

So 10 points are added for every star and the scoreText is updated to show this new total.

<img src="http://www.photonstorm.com/wp-content/uploads/2013/12/part9.png" alt="part9" width="800" height="600" class="alignnone size-full wp-image-13618" />

<h2>Conclusion</h2>

You have now learned how to create a sprite with physical properties, to control its motion and to make it interact with other objects in a small game world. There are  lot more things you can do to enhance this, for example there is no sense of danger or completion yet. Maybe we should add some spikes to avoid? You could create a new 'spikes' group and check for collision vs. the player, only instead of killing the spike sprite you kill the player instead. Or you could a method in update that reduces your score every second to challenge the player to collect the stars as quickly as possible. Your only limited by your creativity<br>
<br>

With the help of what you have learned today and the <a href="http://examples.phaser.io">250+ examples</a> available to you on Phaser's website (examples.phaser.io), you could now have a solid foundation for a future project.

<h3>THANK YOU!</h3>
</body>
</html>